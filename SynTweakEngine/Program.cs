using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;


using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

using Noggog;
using Newtonsoft.Json.Linq;

using SynTweakEngine.Structs;
namespace SynTweakEngine
{
    class Program
    {
        public static Lazy<FileData> LazySettings = new();
        public static FileData data => LazySettings.Value;
        public static JsonMergeSettings merge = new() { MergeArrayHandling = MergeArrayHandling.Union, MergeNullValueHandling = MergeNullValueHandling.Merge };
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings<FileData>("User Tweaks", "User_TWEAKS.json", out LazySettings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "SynTweakEngine.esp")
                .Run(args);
        }
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var files = Directory.GetFiles(state.DataFolderPath).Where(x => x.EndsWith("_TWEAKS.json"));
            var JObj = JObject.FromObject(data);
            files.ForEach(f =>
            {
                JObj.Merge(JObject.Parse(File.ReadAllText(Path.Combine(state.DataFolderPath, f))), merge);
            });
            var fdata = JObj.ToObject<FileData>();
            if (fdata != null)
            {
                if (fdata.FLST != null)
                {
                    foreach (var itm in fdata.FLST)
                    {
                        var Target = state.LinkCache.Resolve<IFormListGetter>(itm.Target.FormKey);
                        if (Target != null)
                        {
                            if (itm.Inject != null)
                            {
                                var tgt = state.PatchMod.FormLists.GetOrAddAsOverride(Target);
                                foreach (var Form in itm.Inject)
                                {
                                    tgt.ContainedFormLinks.Append(Form);
                                }
                            }
                        }
                    }
                }
                if (fdata.MGEF != null)
                {
                    foreach (var itm in fdata.MGEF)
                    {
                        var Target = state.LinkCache.Resolve<IMagicEffectGetter>(itm.Target.FormKey);
                        if (Target != null)
                        {
                            if (itm.HitShader != null)
                            {
                                var tgt = state.PatchMod.MagicEffects.GetOrAddAsOverride(Target);
                                tgt.HitShader = itm.HitShader.Value.AsLink<IEffectShaderGetter>();
                            }
                        }
                    }
                }
                //Spell Handlers
                if (fdata.SPEL != null)
                {
                    foreach (var itm in fdata.SPEL)
                    {
                        var Target = state.LinkCache.Resolve<ISpellGetter>(itm.Target.FormKey);
                        if (Target != null)
                        {
                            if (itm.Add != null || itm.Change != null)
                            {
                                var tgt = state.PatchMod.Spells.GetOrAddAsOverride(Target);
                                //Change Existing Effects
                                if (itm.Change != null)
                                {
                                    foreach (var change in itm.Change)
                                    {
                                        //Duration
                                        if (change.Duration > 0)
                                        {
                                            tgt.Effects[change.Position].Data!.Duration = change.Duration;
                                        }
                                        //Mag
                                        if (change.Mag > 0)
                                        {
                                            tgt.Effects[change.Position].Data!.Magnitude = change.Mag;
                                        }
                                    }
                                }
                                if (itm.Add != null)
                                {
                                    foreach (var add in itm.Add)
                                    {
                                        tgt.Effects.Append(new Effect()
                                        {
                                            BaseEffect = state.LinkCache.Resolve<IMagicEffectGetter>(add.Add.FormKey).AsNullableLink(),
                                            Data = new()
                                            {
                                                Area = add.Area > 0 ? add.Area : 0,
                                                Magnitude = add.Mag > 0 ? add.Mag : 10,
                                                Duration = add.Duration > 0 ? add.Duration : 1
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                //Object Effects
                if (fdata.ENCH != null)
                {
                    foreach (var itm in fdata.ENCH)
                    {
                        var Target = state.LinkCache.Resolve<IObjectEffectGetter>(itm.Target.FormKey);
                        if (Target != null)
                        {
                            if (itm.Add != null || itm.Change != null)
                            {
                                var tgt = state.PatchMod.ObjectEffects.GetOrAddAsOverride(Target);
                                //Change Existing Effects
                                if (itm.Change != null)
                                {
                                    foreach (var change in itm.Change)
                                    {
                                        //Duration
                                        if (change.Duration > 0)
                                        {
                                            tgt.Effects[change.Position].Data!.Duration = change.Duration;
                                        }
                                        //Mag
                                        if (change.Mag > 0)
                                        {
                                            tgt.Effects[change.Position].Data!.Magnitude = change.Mag;
                                        }
                                    }
                                }
                                if (itm.Add != null)
                                {
                                    foreach (var add in itm.Add)
                                    {
                                        tgt.Effects.Add(new Effect()
                                        {
                                            BaseEffect = state.LinkCache.Resolve<IMagicEffectGetter>(add.Add.FormKey).AsNullableLink(),
                                            Data = new()
                                            {
                                                Area = add.Area > 0 ? add.Area : 0,
                                                Magnitude = add.Mag > 0 ? add.Mag : 10,
                                                Duration = add.Duration > 0 ? add.Duration : 1
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}